<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CssSyntaxUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">SmartSprites</a> &gt; <a href="index.source.html" class="el_package">org.carrot2.labs.smartsprites.css</a> &gt; <span class="el_source">CssSyntaxUtils.java</span></div><h1>CssSyntaxUtils.java</h1><pre class="source lang-java linenums">/*
 * SmartSprites Project
 *
 * Copyright (C) 2007-2009, Stanisław Osiński.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * - Redistributions of  source code must  retain the above  copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * - Redistributions in binary form must reproduce the above copyright notice, this
 *   list of conditions and the following  disclaimer in  the documentation  and/or
 *   other materials provided with the distribution.
 *
 * - Neither the name of the SmartSprites Project nor the names of its contributors
 *   may  be used  to endorse  or  promote  products derived   from  this  software
 *   without specific prior written permission.
 *
 * - We kindly request that you include in the end-user documentation provided with
 *   the redistribution and/or in the software itself an acknowledgement equivalent
 *   to  the  following: &quot;This product includes software developed by the SmartSprites
 *   Project.&quot;
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;  AND
 * ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED  TO, THE IMPLIED
 * WARRANTIES  OF  MERCHANTABILITY  AND  FITNESS  FOR  A  PARTICULAR  PURPOSE   ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE  FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL,  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  DAMAGES
 * (INCLUDING, BUT  NOT LIMITED  TO, PROCUREMENT  OF SUBSTITUTE  GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS;  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  ON
 * ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT  LIABILITY,  OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY WAY  OUT OF THE USE  OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package org.carrot2.labs.smartsprites.css;

import java.awt.Color;
import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.carrot2.labs.smartsprites.message.Message;
import org.carrot2.labs.smartsprites.message.Message.MessageType;
import org.carrot2.labs.smartsprites.message.MessageLog;
import org.carrot2.util.StringUtils;

/**
 * A few utility methods for processing CSS syntax.
 */
public class CssSyntaxUtils {

    /** The Constant URL_PATTERN. */
<span class="fc" id="L60">    private static final Pattern URL_PATTERN = Pattern.compile(&quot;[uU][rR][lL]\\((['\&quot;]?)([^'\&quot;]*)\\1\\)&quot;);</span>

    /** The Constant COLOR_PATTERN. */
<span class="fc" id="L63">    private static final Pattern COLOR_PATTERN = Pattern.compile(&quot;#([0-9a-f]{6})&quot;);</span>

    /** The Constant IMPORTANT_PATTERN. */
<span class="fc" id="L66">    private static final Pattern IMPORTANT_PATTERN = Pattern.compile(&quot;!\\s*important&quot;);</span>

    /**
     * Instantiates a new css syntax utils.
     */
    private CssSyntaxUtils() {
        // Prevent Instantiation
    }

    /**
     * Extracts CSS properties from the provided {@link String}.
     *
     * @param text
     *            the text
     *
     * @return the list
     */
    public static List&lt;CssProperty&gt; extractProperties(String text) {
<span class="fc" id="L84">        return extractRules(text, null);</span>
    }

    /**
     * Extracts CSS properties from the provided {@link String} and logs warnings to the provided {@link MessageLog}.
     *
     * @param text
     *            the text
     * @param messageLog
     *            the message log
     *
     * @return the list
     */
    public static List&lt;CssProperty&gt; extractRules(String text, MessageLog messageLog) {
<span class="fc" id="L98">        final List&lt;CssProperty&gt; rules = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L100">        final String[] chunks = text.split(&quot;;&quot;);</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">        for (final String chunk : chunks) {</span>
<span class="fc" id="L102">            final String[] parts = chunk.split(&quot;:&quot;, 2);</span>

<span class="fc bfc" id="L104" title="All 2 branches covered.">            if (parts.length == 2) {</span>
<span class="fc" id="L105">                String value = parts[1].trim();</span>
<span class="fc" id="L106">                final Matcher matcher = IMPORTANT_PATTERN.matcher(value);</span>
<span class="fc" id="L107">                boolean important = false;</span>
<span class="fc bfc" id="L108" title="All 2 branches covered.">                if (matcher.find()) {</span>
<span class="fc" id="L109">                    important = true;</span>
<span class="fc" id="L110">                    value = matcher.replaceAll(&quot;&quot;);</span>
                }

<span class="fc" id="L113">                rules.add(new CssProperty(parts[0].trim().toLowerCase(Locale.ENGLISH), value.trim(), important));</span>
<span class="fc bfc" id="L114" title="All 2 branches covered.">            } else if (messageLog != null) {</span>
<span class="fc" id="L115">                messageLog.warning(Message.MessageType.MALFORMED_CSS_RULE, chunk.trim());</span>
            }
        }

<span class="fc" id="L119">        return rules;</span>
    }

    /**
     * Converts the provided collection of CSS properties to a {@link Map} with keys being property names and values
     * being {@link CssProperty} objects.
     *
     * @param rules
     *            the rules
     *
     * @return the map
     */
    public static Map&lt;String, CssProperty&gt; propertiesAsMap(Collection&lt;CssProperty&gt; rules) {
<span class="fc" id="L132">        final Map&lt;String, CssProperty&gt; result = new LinkedHashMap&lt;&gt;();</span>
<span class="fc bfc" id="L133" title="All 2 branches covered.">        for (final CssProperty cssProperty : rules) {</span>
<span class="fc" id="L134">            result.put(cssProperty.rule, cssProperty);</span>
<span class="fc" id="L135">        }</span>
<span class="fc" id="L136">        return result;</span>
    }

    /**
     * Returns the value of a CSS property if it exists, &lt;code&gt;null&lt;/code&gt; otherwise.
     *
     * @param rules
     *            the rules
     * @param property
     *            the property
     *
     * @return the value
     */
    public static String getValue(Map&lt;String, CssProperty&gt; rules, String property) {
<span class="fc" id="L150">        final CssProperty cssProperty = rules.get(property);</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">        if (cssProperty != null) {</span>
<span class="fc" id="L152">            return cssProperty.value;</span>
        }
<span class="fc" id="L154">        return null;</span>
    }

    /**
     * Returns &lt;code&gt;true&lt;/code&gt; if the the provided map contains a property with the specified name that has a
     * non-blank value.
     *
     * @param properties
     *            the properties
     * @param propertyName
     *            the property name
     *
     * @return true, if successful
     */
    public static boolean hasNonBlankValue(Map&lt;String, CssProperty&gt; properties, String propertyName) {
<span class="pc bpc" id="L169" title="1 of 4 branches missed.">        return properties.containsKey(propertyName) &amp;&amp; StringUtils.isNotBlank(properties.get(propertyName).value);</span>
    }

    /**
     * Extracts the actual url from the CSS url expression like &lt;code&gt;url('actua_url')&lt;/code&gt;.
     *
     * @param urlValue
     *            the url value
     *
     * @return the string
     */
    public static String unpackUrl(String urlValue) {
<span class="fc" id="L181">        return unpackUrl(urlValue, null);</span>
    }

    /**
     * Extracts the actual url from the CSS url expression like &lt;code&gt;url('actua_url')&lt;/code&gt; and logs warnings to the
     * provided {@link MessageLog}.
     *
     * @param urlValue
     *            the url value
     * @param messageLog
     *            the message log
     *
     * @return the string
     */
    public static String unpackUrl(String urlValue, MessageLog messageLog) {
<span class="fc" id="L196">        final Matcher matcher = URL_PATTERN.matcher(urlValue);</span>
<span class="fc bfc" id="L197" title="All 2 branches covered.">        if (!matcher.matches()) {</span>
<span class="pc bpc" id="L198" title="1 of 2 branches missed.">            if (messageLog != null) {</span>
<span class="fc" id="L199">                messageLog.warning(MessageType.MALFORMED_URL, urlValue);</span>
            }
<span class="fc" id="L201">            return null;</span>
        }
<span class="fc" id="L203">        final String url = matcher.group(2);</span>
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">        return url != null ? url.trim() : url;</span>
    }

    /**
     * Parses a hexadecimal format (#fff or #ffffff) of CSS color into a {@link Color} object. The RGB format (rgb(100,
     * 0, 0)) is currently not supported. In case of parse errors, the default is returned
     *
     * @param colorValue
     *            the color value
     * @param messageLog
     *            the message log
     * @param defaultColor
     *            the default color
     *
     * @return the color
     */
    public static Color parseColor(String colorValue, MessageLog messageLog, Color defaultColor) {
<span class="fc" id="L221">        final Matcher matcher = COLOR_PATTERN.matcher(colorValue);</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">        if (!matcher.matches()) {</span>
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">            if (messageLog != null) {</span>
<span class="fc" id="L224">                messageLog.warning(MessageType.MALFORMED_COLOR, colorValue);</span>
            }
<span class="fc" id="L226">            return defaultColor;</span>
        }

<span class="fc" id="L229">        return new Color(Integer.parseInt(matcher.group(1), 16));</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>