<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SpriteImageDirective.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">SmartSprites</a> &gt; <a href="index.source.html" class="el_package">org.carrot2.labs.smartsprites</a> &gt; <span class="el_source">SpriteImageDirective.java</span></div><h1>SpriteImageDirective.java</h1><pre class="source lang-java linenums">/*
 * SmartSprites Project
 *
 * Copyright (C) 2007-2009, Stanisław Osiński.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * - Redistributions of  source code must  retain the above  copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * - Redistributions in binary form must reproduce the above copyright notice, this
 *   list of conditions and the following  disclaimer in  the documentation  and/or
 *   other materials provided with the distribution.
 *
 * - Neither the name of the SmartSprites Project nor the names of its contributors
 *   may  be used  to endorse  or  promote  products derived   from  this  software
 *   without specific prior written permission.
 *
 * - We kindly request that you include in the end-user documentation provided with
 *   the redistribution and/or in the software itself an acknowledgement equivalent
 *   to  the  following: &quot;This product includes software developed by the SmartSprites
 *   Project.&quot;
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;  AND
 * ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT LIMITED  TO, THE IMPLIED
 * WARRANTIES  OF  MERCHANTABILITY  AND  FITNESS  FOR  A  PARTICULAR  PURPOSE   ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE  FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL,  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  DAMAGES
 * (INCLUDING, BUT  NOT LIMITED  TO, PROCUREMENT  OF SUBSTITUTE  GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS;  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  ON
 * ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT  LIABILITY,  OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY WAY  OUT OF THE USE  OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package org.carrot2.labs.smartsprites;

import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;
import com.google.common.collect.Sets;

import java.awt.Color;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.carrot2.labs.smartsprites.css.CssProperty;
import org.carrot2.labs.smartsprites.css.CssSyntaxUtils;
import org.carrot2.labs.smartsprites.message.Message.MessageType;
import org.carrot2.labs.smartsprites.message.MessageLog;
import org.carrot2.util.CollectionUtils;
import org.carrot2.util.StringUtils;

/**
 * Represents a directive that declares an individual sprite image.
 */
public class SpriteImageDirective {

    /** The Constant PROPERTY_SPRITE_ID. */
    public static final String PROPERTY_SPRITE_ID = &quot;sprite&quot;;

    /** The Constant PROPERTY_SPRITE_IMAGE_LAYOUT. */
    public static final String PROPERTY_SPRITE_IMAGE_LAYOUT = &quot;sprite-layout&quot;;

    /** The Constant PROPERTY_SPRITE_IMAGE_URL. */
    public static final String PROPERTY_SPRITE_IMAGE_URL = &quot;sprite-image&quot;;

    /** The Constant PROPERTY_SPRITE_IMAGE_UID_SUFFIX. */
    public static final String PROPERTY_SPRITE_IMAGE_UID_SUFFIX = &quot;sprite-image-uid&quot;;

    /** The Constant PROPERTY_SPRITE_MATTE_COLOR. */
    public static final String PROPERTY_SPRITE_MATTE_COLOR = &quot;sprite-matte-color&quot;;

    /** The Constant PROPERTY_SPRITE_SCALE. */
    public static final String PROPERTY_SPRITE_SCALE = &quot;sprite-scale&quot;;

    /** A set of allowed properties. */
<span class="fc" id="L81">    private static final Set&lt;String&gt; ALLOWED_PROPERTIES = ImmutableSet.of(PROPERTY_SPRITE_ID,</span>
            PROPERTY_SPRITE_IMAGE_LAYOUT, PROPERTY_SPRITE_IMAGE_URL, PROPERTY_SPRITE_MATTE_COLOR, PROPERTY_SPRITE_SCALE,
            PROPERTY_SPRITE_IMAGE_UID_SUFFIX);

    /**
     * Defines the layout of this sprite.
     */
<span class="fc" id="L88">    public enum SpriteImageLayout {</span>
        /**
         * Vertical layout, images stacked on each other.
         */
<span class="fc" id="L92">        VERTICAL,</span>

        /**
         * Horizontal layout, images next to each other.
         */
<span class="fc" id="L97">        HORIZONTAL;</span>

        /** The value. */
        private final String value;

        /**
         * Instantiates a new sprite image layout.
         */
<span class="fc" id="L105">        SpriteImageLayout() {</span>
<span class="fc" id="L106">            this.value = name().toLowerCase(Locale.ENGLISH);</span>
<span class="fc" id="L107">        }</span>

        @Override
        public String toString() {
<span class="fc" id="L111">            return value;</span>
        }

        /**
         * Values as string.
         *
         * @return the string
         */
        public static String valuesAsString() {
<span class="fc" id="L120">            final String list = Lists.newArrayList(values()).toString();</span>
<span class="fc" id="L121">            return list.substring(1, list.length() - 1);</span>
        }
    }

    /**
     * Defines the UID Generation Mode of this sprite.
     */
<span class="fc" id="L128">    public enum SpriteUidType {</span>
        /**
         * No UID extension.
         */
<span class="fc" id="L132">        NONE,</span>

        /**
         * Append current timestamp as long.
         */
<span class="fc" id="L137">        DATE,</span>

        /**
         * Append sha512 of the sprites file.
         */
<span class="fc" id="L142">        SHA512;</span>

        /** The value. */
        private final String value;

        /** The pattern. */
        public final Pattern pattern;

        /**
         * Instantiates a new sprite uid type.
         */
<span class="fc" id="L153">        SpriteUidType() {</span>
<span class="fc" id="L154">            this.value = name().toLowerCase(Locale.ENGLISH);</span>
<span class="fc" id="L155">            this.pattern = Pattern.compile(&quot;${&quot; + value + &quot;}&quot;, Pattern.LITERAL);</span>
<span class="fc" id="L156">        }</span>

        @Override
        public String toString() {
<span class="fc" id="L160">            return value;</span>
        }

        /**
         * Values as string.
         *
         * @return the string
         */
        public static String valuesAsString() {
<span class="fc" id="L169">            final String list = Lists.newArrayList(values()).toString();</span>
<span class="fc" id="L170">            return list.substring(1, list.length() - 1);</span>
        }
    }

    /**
     * Defines supported image file formats.
     */
<span class="fc" id="L177">    public enum SpriteImageFormat {</span>

        /** The png. */
<span class="fc" id="L180">        PNG,</span>
        /** The gif. */
<span class="fc" id="L182">        GIF,</span>
        /** The jpg. */
<span class="fc" id="L184">        JPG;</span>

        /** The value. */
        private final String value;

        /**
         * Instantiates a new sprite image format.
         */
<span class="fc" id="L192">        SpriteImageFormat() {</span>
<span class="fc" id="L193">            this.value = name().toLowerCase(Locale.ENGLISH);</span>
<span class="fc" id="L194">        }</span>

        @Override
        public String toString() {
<span class="fc" id="L198">            return value;</span>
        }

        /**
         * Gets the value.
         *
         * @param value
         *            the value
         *
         * @return the value
         */
        public static SpriteImageFormat getValue(String value) {
<span class="fc" id="L210">            return valueOf(value.toUpperCase(Locale.ENGLISH));</span>
        }

        /**
         * Values as string.
         *
         * @return the string
         */
        public static String valuesAsString() {
<span class="fc" id="L219">            final String list = Lists.newArrayList(values()).toString();</span>
<span class="fc" id="L220">            return list.substring(1, list.length() - 1);</span>
        }
    }

    /**
     * Unique identified of this sprite.
     */
    public final String spriteId;

    /**
     * CSS file relative path for this sprite image.
     */
    public final String imagePath;

    /**
     * Non-file-name extension after the sprite image path to force a cache update on change, prefixed by '?'.
     */
    public final SpriteUidType uidType;

    /**
     * Layout of this sprite image.
     */
    public final SpriteImageLayout layout;

    /**
     * Format of this sprite image.
     */
    public final SpriteImageFormat format;

    /**
     * Matte color to be used when reducing true alpha channel.
     */
    public final Color matteColor;

    /**
     * Scaling ratio to apply to background; default is 1.
     */
    public final float scaleRatio;

    /**
     * Sprite layout properties defined at the sprite image directive level. The defaults provided here can be
     * overridden at the sprite reference directive level.
     */
    public final SpriteLayoutProperties spriteLayoutProperties;

    /**
     * Pattern for a simple syntactic check of the image path.
     */
<span class="fc" id="L268">    private static final Pattern IMAGE_PATH_PATTERN = Pattern.compile(&quot;([^${}]*|\\$\\{[^}]*\\})*&quot;);</span>

    /**
     * Pattern for extracting variables from image path.
     */
<span class="fc" id="L273">    private static final Pattern IMAGE_PATH_VARIABLE_PATTERN = Pattern.compile(&quot;\\$\\{([a-z]*)\\}&quot;);</span>

    /**
     * Variable names allowed in image path.
     */
<span class="fc" id="L278">    private static final Set&lt;String&gt; ALLOWED_VARIABLES = ImmutableSet.of(PROPERTY_SPRITE_ID,</span>
<span class="fc" id="L279">            SpriteUidType.DATE.toString(), SpriteUidType.SHA512.toString());</span>

    /**
     * Instantiates a new sprite image directive.
     *
     * @param id
     *            the id
     * @param imageUrl
     *            the image url
     * @param layout
     *            the layout
     * @param format
     *            the format
     * @param matteColor
     *            the matte color
     * @param uidType
     *            the uid type
     * @param scale
     *            the scale
     */
    public SpriteImageDirective(String id, String imageUrl, SpriteImageLayout layout, SpriteImageFormat format,
            Color matteColor, SpriteUidType uidType, float scale) {
<span class="fc" id="L301">        this(id, imageUrl, layout, format, matteColor, uidType, scale, new SpriteLayoutProperties(layout));</span>
<span class="fc" id="L302">    }</span>

    /**
     * Instantiates a new sprite image directive.
     *
     * @param id
     *            the id
     * @param imageUrl
     *            the image url
     * @param layout
     *            the layout
     * @param format
     *            the format
     * @param matteColor
     *            the matte color
     * @param uidType
     *            the uid type
     * @param scale
     *            the scale
     * @param spriteLayoutProperties
     *            the sprite layout properties
     */
    public SpriteImageDirective(String id, String imageUrl, SpriteImageLayout layout, SpriteImageFormat format,
<span class="fc" id="L325">            Color matteColor, SpriteUidType uidType, float scale, SpriteLayoutProperties spriteLayoutProperties) {</span>
<span class="fc" id="L326">        this.spriteId = id;</span>
<span class="fc" id="L327">        this.imagePath = imageUrl;</span>
<span class="fc" id="L328">        this.layout = layout;</span>
<span class="fc" id="L329">        this.format = format;</span>
<span class="fc" id="L330">        this.matteColor = matteColor;</span>
<span class="fc" id="L331">        this.uidType = uidType;</span>
<span class="fc" id="L332">        this.scaleRatio = scale;</span>
<span class="fc" id="L333">        this.spriteLayoutProperties = spriteLayoutProperties;</span>
<span class="fc" id="L334">    }</span>

    /**
     * Parses a string into a {@link SpriteImageDirective}, logging messages to the provided {@link MessageLog}s.
     *
     * @param directiveString
     *            the directive string
     * @param messageCollector
     *            the message collector
     *
     * @return the sprite image directive
     */
    public static SpriteImageDirective parse(String directiveString, MessageLog messageCollector) {
<span class="fc" id="L347">        final Map&lt;String, CssProperty&gt; rules = CssSyntaxUtils</span>
<span class="fc" id="L348">                .propertiesAsMap(CssSyntaxUtils.extractRules(directiveString, messageCollector));</span>

<span class="fc" id="L350">        final Set&lt;String&gt; properties = Sets.newLinkedHashSet(rules.keySet());</span>
<span class="fc" id="L351">        properties.removeAll(ALLOWED_PROPERTIES);</span>
<span class="fc" id="L352">        properties.removeAll(SpriteLayoutProperties.ALLOWED_PROPERTIES);</span>
<span class="fc bfc" id="L353" title="All 2 branches covered.">        if (!properties.isEmpty()) {</span>
<span class="fc" id="L354">            messageCollector.warning(MessageType.UNSUPPORTED_PROPERTIES_FOUND, CollectionUtils.toString(properties));</span>
        }

<span class="fc bfc" id="L357" title="All 2 branches covered.">        if (!CssSyntaxUtils.hasNonBlankValue(rules, PROPERTY_SPRITE_ID)) {</span>
<span class="fc" id="L358">            messageCollector.warning(MessageType.SPRITE_ID_NOT_FOUND);</span>
<span class="fc" id="L359">            return null;</span>
        }

<span class="fc bfc" id="L362" title="All 2 branches covered.">        if (!CssSyntaxUtils.hasNonBlankValue(rules, PROPERTY_SPRITE_IMAGE_URL)) {</span>
<span class="fc" id="L363">            messageCollector.warning(MessageType.SPRITE_IMAGE_URL_NOT_FOUND);</span>
<span class="fc" id="L364">            return null;</span>
        }

<span class="fc" id="L367">        final String id = rules.get(PROPERTY_SPRITE_ID).value;</span>

<span class="fc" id="L369">        final SpriteUidType uidGenerator = valueOf(CssSyntaxUtils.getValue(rules, PROPERTY_SPRITE_IMAGE_UID_SUFFIX),</span>
                SpriteUidType.class, SpriteUidType.NONE, messageCollector, MessageType.UNSUPPORTED_UID_TYPE);
<span class="fc bfc" id="L371" title="All 2 branches covered.">        if (uidGenerator != SpriteUidType.NONE) {</span>
<span class="fc" id="L372">            messageCollector.deprecation(MessageType.DEPRECATED_SPRITE_IMAGE_UID, uidGenerator.toString());</span>
        }

        // Image path. If the path does not match a regular expression, issue a warning.
<span class="fc" id="L376">        final String imagePath = CssSyntaxUtils.unpackUrl(rules.get(PROPERTY_SPRITE_IMAGE_URL).value);</span>
<span class="fc bfc" id="L377" title="All 2 branches covered.">        if (IMAGE_PATH_PATTERN.matcher(imagePath).matches()) {</span>
            // Check variable names
<span class="fc" id="L379">            final Matcher variableMatcher = IMAGE_PATH_VARIABLE_PATTERN.matcher(imagePath);</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">            while (variableMatcher.find()) {</span>
<span class="pc bpc" id="L381" title="1 of 4 branches missed.">                if (variableMatcher.groupCount() == 1 &amp;&amp; !ALLOWED_VARIABLES.contains(variableMatcher.group(1))) {</span>
<span class="fc" id="L382">                    messageCollector.warning(MessageType.UNSUPPORTED_VARIABLE_IN_SPRITE_IMAGE_PATH,</span>
<span class="fc" id="L383">                            variableMatcher.group(1));</span>
                }
            }
<span class="fc" id="L386">        } else {</span>
            // Just issue a warning
<span class="fc" id="L388">            messageCollector.warning(MessageType.MALFORMED_SPRITE_IMAGE_PATH, imagePath);</span>
        }

        // Layout is optional
<span class="fc" id="L392">        final SpriteImageLayout layout = valueOf(CssSyntaxUtils.getValue(rules, PROPERTY_SPRITE_IMAGE_LAYOUT),</span>
                SpriteImageLayout.class, SpriteImageLayout.VERTICAL, messageCollector, MessageType.UNSUPPORTED_LAYOUT);

        // Infer format from image path
        SpriteImageFormat format;
<span class="fc" id="L397">        final int lastDotIndex = imagePath.lastIndexOf('.');</span>
<span class="pc bpc" id="L398" title="1 of 4 branches missed.">        if (lastDotIndex &lt; 0 || lastDotIndex == imagePath.length() - 1) {</span>
<span class="fc" id="L399">            messageCollector.warning(MessageType.CANNOT_DETERMINE_IMAGE_FORMAT, imagePath);</span>
<span class="fc" id="L400">            format = SpriteImageFormat.PNG;</span>
        } else {
<span class="fc" id="L402">            final int questionMarkIndex = imagePath.indexOf('?', lastDotIndex);</span>
<span class="fc bfc" id="L403" title="All 2 branches covered.">            final String formatValue = questionMarkIndex &gt;= 0 ? imagePath.substring(lastDotIndex + 1, questionMarkIndex)</span>
<span class="fc" id="L404">                    : imagePath.substring(lastDotIndex + 1);</span>
            try {
<span class="fc" id="L406">                format = SpriteImageFormat.getValue(formatValue);</span>
<span class="fc" id="L407">            } catch (final IllegalArgumentException e) {</span>
<span class="fc" id="L408">                messageCollector.warning(MessageType.UNSUPPORTED_SPRITE_IMAGE_FORMAT, formatValue);</span>
<span class="fc" id="L409">                format = SpriteImageFormat.PNG;</span>
<span class="fc" id="L410">            }</span>
        }

        // Matte color
        final Color matteColor;
<span class="fc bfc" id="L415" title="All 2 branches covered.">        if (CssSyntaxUtils.hasNonBlankValue(rules, PROPERTY_SPRITE_MATTE_COLOR)) {</span>
<span class="fc" id="L416">            matteColor = CssSyntaxUtils.parseColor(rules.get(PROPERTY_SPRITE_MATTE_COLOR).value, messageCollector,</span>
                    null);
        } else {
<span class="fc" id="L419">            matteColor = null;</span>
        }

        final float scale;
<span class="fc bfc" id="L423" title="All 2 branches covered.">        if (CssSyntaxUtils.hasNonBlankValue(rules, PROPERTY_SPRITE_SCALE)) {</span>
<span class="fc" id="L424">            scale = Float.parseFloat(rules.get(PROPERTY_SPRITE_SCALE).value);</span>
        } else {
<span class="fc" id="L426">            scale = 1.0f;</span>
        }

<span class="fc" id="L429">        return new SpriteImageDirective(id, imagePath, layout, format, matteColor, uidGenerator, scale,</span>
<span class="fc" id="L430">                SpriteLayoutProperties.parse(directiveString, layout, messageCollector));</span>
    }

    /**
     * Value of.
     *
     * @param &lt;T&gt;
     *            the generic type
     * @param stringValue
     *            the string value
     * @param enumClass
     *            the enum class
     * @param defaultValue
     *            the default value
     * @param messageCollector
     *            the message collector
     * @param messageType
     *            the message type
     *
     * @return the t
     */
    private static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(String stringValue, Class&lt;T&gt; enumClass, T defaultValue,
            MessageLog messageCollector, MessageType messageType) {
<span class="fc bfc" id="L453" title="All 2 branches covered.">        if (!StringUtils.isNotBlank(stringValue)) {</span>
<span class="fc" id="L454">            return defaultValue;</span>
        }
        try {
<span class="fc" id="L457">            return Enum.valueOf(enumClass, stringValue.toUpperCase(Locale.ENGLISH));</span>
<span class="fc" id="L458">        } catch (IllegalArgumentException e) {</span>
<span class="fc" id="L459">            messageCollector.warning(messageType, stringValue);</span>
<span class="fc" id="L460">            return defaultValue;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>